=encoding utf8

=head1 NAME

Tutorial Joose JS - em portugês

=head2 SYNOPSE

Joose é um sistema de meta objetos para javascript que suporta:

  classes
  herança
  traits
  modificadores de método

E permite que você crie classes como se fosse LEGO, literalmente.

=head2 DESCRIÇÃO

Joose é um sistema de meta objetos para javascript.

O joose facilita o trabalho com orientação a objeto no javascript. Fica mais fácil, declarativo e aumenta a produtividade. O sistema de meta objetos do joose é multiparadigma, ou seja, ele suporta desenvolvimento voltado a classes, prototypos e tambem suporta herança de classes e extensão com roles.

Importante, o joose não serve apenas para frontend. Tambem é muito usado no backend junto com nodejs. É importante entender que o joose não está atrelado a markup nem a views. No entando ele pode ser usado no frontend (browser) e usar jquery ou javascript puro para modificar o dom e etc. E o Angular, Dojo, ExtJS, etc por exemplo podem ser usadas em conjutno com o joose.

O joose ajuda a trabalhar com classes, namespaces, heranças, roles, reduzir o número de linhas, reutilizar código e aumentar a produtividade.

=head2 O que NÃO é Joose JS

Joose não é um manipulador de DOM. Ex. ele não faz o que o jquery faz.

Ele não trabalha no nível de markup. Mas pode ser usado em conjunto com jquery.

=head3 Seters, getters

Como é feito normalmente em js: 

  pessoa = {
    //nome
    nome      : null,
    setNome  : function ( val ) { 
      this.nome = val;
    },
    getNome  : function () { 
      return this.nome;
    },

    //sobrenome
    sobrenome      : null,
    setSobrenome  : function ( val ) { 
      this.sobrenome = val;
    },
    getSobrenome  : function () { 
      return this.sobrenome;
    },

    //idade
    idade    : null,
    setIdade  : function ( val ) {
      this.idade = val;
    },
    getIdade  : function () { 
      return this.idade;
    },

  };
  pessoa.setNome("João");
  pessoa.setSobrenome("Silva");
  pessoa.setIdade(50);

  pessoa.getNome();

Não ha necessidade de ficar declarando setters e getters pois todo atributo tem um setter e um geter criado implicitamente. Você pode mudar o nome dos getters e setters. Especialmente se quiser usar um after ou before de setters ou getters.

ex: 

  Class( "Pessoa", {
      has: {
          nome        : { is: 'rw' },
          sobrenome   : { is: 'rw' },
          idade       : { is: 'rw' },
          amigos      : { is: 'rw', init: (function() { })( return [] ) }, // Array
      }
  } )
  var pessoa = new Pessoa();
  pessoa.setNome( "João" );
  pessoa.setSobrenome( "João" );
  pessoa.setIdade( "João" );
  pessoa.setAmigos( [ 'Maria','José' ] );

ou melhor ainda... é permitiro passar o objeto e ele automagicamente seta para vc, ex:

  var pessoa_item = {
          nome : "João",
     sobrenome : "Silva",
         idade : 50,
        amigos : [ "José", "Maria" ]
  }

  var p = new Pessoa( pessoa_item );
  console.log( p.nome );      // João
  console.log( p.sobrenome ); // Silva

=head3 Atributos

=head3 Métodos

=head3 Modificadores de métodos

=head3 Classes

=head3 Roles

=head3 Requires

=head3 Traits

=head3 Types

Type coercions have been proven to be extremely useful in JavaScript code because many tasks in JavaScript deal with user provided data that is in string form. Coercions provide a very convenient way to transform this string data into meaningful things. After the definition of the types your application code can basically "ignore" things like data validation and conversion. This makes the code more expressive and should reduce errors because it is harder to forget to validate data.

REFENCIA: http://www.nonblocking.io/2009/01/type-contraints-and-type-coercions-in.html 

=head3 Namespaces

=head3 Singletons

=head3 Prototypes

=head2 Exemplo prático

=head3 Calculadora

Como exemplo incial, vou começar com uma calculadora. A idéia é criar uma classe inicial com as funções básicas de somar, subtrair, dividir e multiplicar e um atributo resultado.

  Class( "Calculadora", {
    has : {
      resultado: { is : "rw", init: (function() { return 0 }) }
    },
    methods : {
      adicionar: function ( val1,val2 ) {
        this.setResultado( val1 + val2 );
        return this;
      },
      subtrair: function( val1,val2 ) {
        this.setResultado( val1 - val2 );
        return this;
      },
      multiplicar: function ( val1, val2 ) {
        this.setResultado( val1 * val2 );
        return this;
      },
      dividir: function( val1, val2 ) {
        this.setResultado( val1 / val2 );
        return this;
      },
      zerar: function( ) {
        this.setResultado( 0 );
        return this;
      }
    }
  } )

e a seguir, um exemplo de uso:

  var calc = new Calculadora();
  calc.adicionar( 1, 2 );         //soma 1 com 2 e armazena o resultado no atributo "resultado"
  console.log( calc.resultado );  //mostra 3

Nos próximos capítulos, a calculadora será extendida para ter mais funcionalidades mas sem mexer na calculadora básica.

=head3 Extendendo a calculadora - Raíz quadrada

Para extender a calculadora, vou criar uma Role que contém um método de raíz quadrada

=head4 Referências

http://code.google.com/p/joose-js/

Alguns trechos são traduzidos/copiados da documentação oficial do joose.

=head4 Autor

=head4 Colaboradores

Se você ajudar a melhorar este documento, adicione seu nome abaixo.

=cut
