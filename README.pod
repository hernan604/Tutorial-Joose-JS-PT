=encoding utf8

=head1 NAME

Tutorial Joose JS - em portugês

=head2 SYNOPSE

Joose é um sistema de meta objetos para javascript que suporta:

  classes
  herança
  traits / roles
  modificadores de método

E permite que você crie classes como se fosse LEGO, literalmente.

=head2 DESCRIÇÃO

O joose facilita o trabalho com orientação a objeto no javascript. Fica mais fácil, declarativo e aumenta a produtividade. O sistema de meta objetos do joose é multiparadigma, ou seja, ele suporta desenvolvimento voltado a classes, prototypos e tambem suporta herança de classes e extensão com roles.

Importante, o joose não serve apenas para frontend. Tambem é muito usado no backend junto com nodejs. É importante entender que o joose não está atrelado a markup nem a views. No entando ele pode ser usado no frontend (browser) e usar jquery ou javascript puro para modificar o dom e etc. E o Angular, Dojo, ExtJS, etc por exemplo podem ser usadas em conjutno com o joose.

O joose ajuda a trabalhar com classes, namespaces, heranças, roles, reduzir o número de linhas, reutilizar código e aumentar a produtividade.

=head2 O que NÃO é Joose JS

Joose não é um manipulador de DOM. Ex. ele não faz o que o jquery faz.

Ele não trabalha no nível de markup. Mas pode ser usado em conjunto com jquery, dojo, angular, extjs, etc.

=head3 Seters, getters

Como é feito normalmente em js: 

  pessoa = {
    //nome
    nome      : null,
    setNome  : function ( val ) { 
      this.nome = val;
    },
    getNome  : function () { 
      return this.nome;
    },

    //sobrenome
    sobrenome      : null,
    setSobrenome  : function ( val ) { 
      this.sobrenome = val;
    },
    getSobrenome  : function () { 
      return this.sobrenome;
    },

    //idade
    idade    : null,
    setIdade  : function ( val ) {
      this.idade = val;
    },
    getIdade  : function () { 
      return this.idade;
    },

  };
  pessoa.setNome("João");
  pessoa.setSobrenome("Silva");
  pessoa.setIdade(50);

  pessoa.getNome();

O trecho acima é uma maneira comum de definir getters e setters. Na minha opinião isso acaba poluíndo o código e adiciona pontos de falha, e no final são apenas getters e setters que não servem pra nada alem de setar e retornar valor. Os getters e setters podem ser muito mais úteis utilizando um sistema de meta objetos.

No JooseJS não há necessidade de ficar declarando setters e getters pois todo atributo tem um setter e um geter criado implicitamente. Além disso, é como os getters e setters são apenas métodos, você ganha instantaneamente a possibilidade de utilizar modificadores de métodos nos atributos.

Neste exemplo vou criar e definir minha classe Pessoa: 

  Class( "Pessoa", {
      has: {
          nome        : { is: 'rw' },
          sobrenome   : { is: 'rw' },
          idade       : { is: 'rw' },
          amigos      : { is: 'rw', init: (function() { return [] })( ) }, // amigos é inicializa com array vazio por padrão
      }
  } )

Agora, vou instanciar a classe e setar alguns atributos manualmente

  var pessoa = new Pessoa();
  pessoa.setNome( "João" );
  pessoa.setSobrenome( "João" );
  pessoa.setIdade( "João" );
  pessoa.setAmigos( [ 'Maria','José' ] );

ou melhor ainda, vou instanciar a classe passando um objeto e a classe é automagicamente populada para vc, ex:

  var pessoa_item = {
          nome : "João",
     sobrenome : "Silva",
         idade : 50,
        amigos : [ "José", "Maria" ]
  }

  var p = new Pessoa( pessoa_item );
  console.log( p.nome );      // João
  console.log( p.sobrenome ); // Silva
  console.log( p.idade );     // 50
  console.log( p.amigos );    // [ "José", "Maria" ]

menos código, menos bugs. Mais clean.

Na situação acima, se vc trabalhar com objetos que são recebidos de um banco de dados, ou um json podem ser jogados diretamente ao criar a instância. Mão na roda.

=head3 Atributos

Todas as Classes e Roles podem ter atributos. Ao registrar um atributo para sua classe, um attribute accessor é criado para você.

Os atributos ficam dentro do bloco has. 
  
  has: {
      nome: { 
          is: "rw"    //rw = readwrite. Ou seja, é permitido escrever nesse atributo
      },
      sexo: {
                is : "ro"    //ro = readonly. Ou seja, não é permitido escrever nesse atributo
          required : true,   //indica que o atributo é requerido
              lazy : true,   //indice que o atributo é lazy
                             //existem outras opções no manual do joose
      }
  }

Foi escolhido 'has' pois atributos são considerados membros de um objeto, ou seja, "um objeto has um atributo", ou "um objeto tem um atributo", ou "uma pessoa tem um nome"

Isso quer dizer que você só indica o nome do atributo. Os getters e setters são criados automagicamente behind-the-scenes.

o padrão para os accessors é "set" junto com a-primeira-letra-do-atributo-em-maiúscula, ex:

  Class( "Pessoa" , {
    has: {
      nome: { is: "rw" }          //atributo nome
    },
    methods: {
      dizer_nome: function () { 
        console.log( this.nome ); //acessa atrituto nome dentro da classe Pessoa
      }
    }
  } )

  var pessoa = new Pessoa();

o setter fica:

  pessoa.setNome( "valor" )

e o getter fica:

  pessoa.getNome()

óbviamente que tambem é possível acessar diretamente o atributo:

  pessoa.nome

  ou 

  pessoa.nome = "Mônica"

Mas provavelmente você não quer fazer isso pois vai perder a facilidade dos modificadores de método.

Resumindo, para acessar os atributos de fora da classe:

  pessoa.nome

e para acessar de dentro da classe:

  this.setNome( '...' );
  this.getNome()
  this.nome

mas ao vc acessar/setar diretamente o atributo, vc perde a facilidade dos modificadors de método para getPessoa e setPessoa.

=head3 Métodos

Os métodos podem ser definidos tanto em Classes quanto em Roles. e ficam dentro do bloco methods:{ ... }, ex:

  Role( "Lixeiro", {    //Roles tambem podem ter métodos
    methods : { 
      limpar_cidade: function () { 
        console.log( "Sou lixeiro, mantenho a cidade limpa. Você ajuda a manter a cidade limpa? hm... :)" );
      }
    }
  } )

  Class( "Programador", {
    isa : Pessoa,         //herda da classe Pessoa
    has : {
      is_hacker : { is: "rw", init: ( function() { true } )() }
      linguagem : { is: "rw"  },
    },
    methods : {               //bloco de métodos relacionado à classe Programador
      programar: function () {
        console.log( "programando.... " );
      },
      hackear: function() {
        if ( ! this.is_hacker ) return;
        console.log( "hummmmm hacker :p" );
      }
    }
  } )

A classe Programador acima, herda de pessoa, então ela tem todas as funcionalidades da classe pessoa.

Alem disso, alguns métodos são definidos especificamente nesta classe, são eles:

  programar
  hackear

Então eu poderia fazer isto por exemplo:

  var dados = {
         nome : "Linus Torvalds",
    is_hacker : true,
    linguagem : [ "c", "cpp" ]
  }

  var programador = new Programador( dados );

  programador.programar() // programando...
  programador.hackear()   // hummmmm hacker :p

mas e se eu passar is_hacker = false

  programador.setIs_hacker( false );
  programador.hackear();  // vai fazer nada pois não é hacker

para setar atributos dentro dos métodos é só fazer:

  this.setNome("...")
  this.getnome()
  this.nome

=head3 Modificadores de métodos

Os modificadores de métodos tem muitos usos. Eles são bastante usados em Roles pois as roles extendem as classes e assim é possível pegar carona nos métodos sem necessariamente alterar os métodos da classe principal.

Os modificadores de método recebem os mesmos atritos enviados para o método original.

Existem 4 modificadores de método:

  before 
  after
  override
  around

Before e After rodam antes e depois dos métodos respectivamente e não permitem alterar o valor enviado e nem o valor retornado pelo método original. Um exemplo de uso seria registrar um 'log' da ação executada. ex:

  Class( "Pessoa", {
    has : {
      nome : { is: "rw" }
    },
    before: { 
      setNome: function( nome ) {
        console.log( "LOG: Antes de setar atributo nome, com valor: " + nome );
      }
    },
    after: {
      setNome: function( nome ) { 
        console.log( "LOG: Após setar atributo nome, com valor: " + nome );
      }
    }
  } )

Então se eu instanciar essa classe e setar um valor para o atributo nome, ela vai fazer o seguinte:

  var pessoa = new Pessoa();
  pessoa.setNome( "Joe" );

  "Antes de setar atributo nome"<-- aparece antes da classe chamar o método setNome
  "Após setar atributo nome"    <-- aparece após a classe setar um valor para o atributo nome

Outros modificadores de métodos mais poderosos são o Override e Around. Estes podem modificar os argumentos passados originalmente para um método e você consegue até decidir se quer ou não chamar o método original. Também é possível modificar o valor retornado pelo método original, ex:

  Class( "Pessoa", {

    // Métodos 

    methods: {
      dizer_frase: function ( frase ) {
        return "dizendo: " + frase ;
      },
      perguntar_frase: function( pergunta ) {
        return "perguntando: " + pergunta;
      },
    },

    // Meus overrides

    override: {
      dizer_frase: function( frase ) {
        return this.SUPER( false ) + " - OVERRIDE";
      }
    },

    //Meus arounds

    around: {
      perguntar_frase: function ( original, pergunta ) { //original é a referencia ao método original
        return ( pergunta && pergunta.length > 10 ) 
          ? original( pergunta )        //chama o método original
          : "pergunta muito curta";     //não chama método orignal e retorna este valor
      }
    },
  } )

  var pessoa = new Pessoa();
  console.log( pessoa.dizer_frase( "Tambem sei falar!" ) );
  console.log( pessoa.perguntar_frase( "Nome?" ) );
  console.log( pessoa.perguntar_frase( "Qual seu nome ?" ) );

=head3 Diferença entre classes e roles

A principal diferença entre classes e roles é que classes podem ser instanciadas e roles não. As roles podem ser consumidas por outras classes e outras roles.

Pra falar bem grossamente, uma classe pode ser montada com várias roles. Parece lego.

=head3 Classes

As classes podem ser instanciadas, ou seja, é possível fazer:

  var pessoa = new Pessoa();

  ou 

  item = { nome: "João", idade: 50 };
  var pessoa = new Pessoa( item );

como sempre, as classes podem ter atributos, metodos, modificadores de métodos. 

Tambem podem ser construídas com outras roles, utilizando a diretiva 'does', por exemplo:

Vou definir uma Role de Programador:

  Role( "Programador", {
    has: {
      linguagens: { is: "rw" }
    },
    methods: {
      programar: function() {
        console.log('programando...')
      }
    }
  } )

E uma classe pessoa, que vai exercer tambem o papel de programador

  Class( "Pessoa", {
    does: [ Programador ],
    has: {
      nome: { is: "rw" }
    },
    methods: {
      andar: function() {
        console.log( "andar..." );
      },
      dizer_nome: function () {
        console.log( this.nome );
      }
    }
  } )

=head3 Roles / Traits

As roles não podem ser instanciadas, ou seja, não é possível fazer:

  var role_programador = new Programador_Role(); // Se Programador_Role for uma role, isso vai não vai funcionar.

As roles são para ser utilizadas nas classes ou em outras roles. Role em inglês quer dizer "papel", no sentido de atores por exemplo.. uma hora o ator exerce o papel de algo. Ou, por exemplo no caso de classe "Pessoa" ela pode ter uma "Role" de "Programador", ou pode ter uma role de "Mecanico", etc. 

Para usar uma role, é necessário incluir a mesma na diretiva "does". pode ser apenas uma, mas tambem pode ser um array de roles. Então vou definir algumas roles que poderiam ser usadas com Pessoa ex:

  Role( "Corredor", { 
    methods: {
      correr: function () { console.log( "correndo.." ) }  
    }
  } )

  Role( "Nadador", { 
    methods: {
      nadar: function () { console.log( "nadando.." ) }
    }
  } )

  Role( "Ciclista", { 
    methods: {
      andar_de_bike: function () { console.log( "andando de bike" ) }
    }
  } )

e agora vou usá-las em Pessoa

  Role( "Pessoa", { 
    does: Nadador,
    has : {
      nome : { is: "rw" },
      sobrenome: { is: "rw" }
    }
  } )

ou , se eu preferir posso transformar a pessoa em tri-atleta facilmente:

  Role( "Triatleta" , { 
    does: [ Pessoa, Nadador, Ciclista, Corredor ]
  } )

Vou dar um exemplo de uma classe CalculadoraBase que implementa as funções básicas do módulo calculadora. E logo em seguida vou adicionar uma role de RaizQuadrada nessa Calculadora. E dai vou poder calcular a raiz quadrada, mas sem mexer no CalculadoraBase:

  Class( "CalculadoraBase", {
    has : {
      resultado: { is : "rw", init: (function() { return 0 }) }
    },
    methods : {
      adicionar: function ( val1,val2 ) {
        this.setResultado( val1 + val2 );
        return this;
      },
      subtrair: function( val1,val2 ) {
        this.setResultado( val1 - val2 );
        return this;
      },
      multiplicar: function ( val1, val2 ) {
        this.setResultado( val1 * val2 );
        return this;
      },
      dividir: function( val1, val2 ) {
        this.setResultado( val1 / val2 );
        return this;
      },
      zerar: function( ) {
        this.setResultado( 0 );
        return this;
      }
    }
  } )

e vou definir tambem algumas roles, que eu posso ou não usar.. fica a meu critério:

  Role( "RaizQuadrada", {
    methods: {
      raiz_quadrada: function( val1 ) {
        this.setResultado(  Math.sqrt( val1 )  );
        return this;
      }
    }
  } )

  Role( "Potencia" , {
    methods: {
      elevar: function ( val1, val2 ) {
        this.setResultado( Math.pow( val1, val2 ) );
        return this;
      }
    }
  } )

certo, agora que eu tenho uma classe e algumas roles, eu vou criar uma classe "Calculadora" que vai herdar de CalculadoraBase e alem disso vou adicionar as roles de RaizQuadrada e Potencia na minha calculadora:

  Class( "Calculadora", {
     isa : CalculadoraBase,
    does : [
      RaizQuadrada,   //agora esta classe implementa as funcionalidades de raiz quadrada
      Potencia,       //agora tambem implementa funcionaldiade de potencia
    ]
  } )

  var calc = new Calculadora();
  console.log( calc.elevar( 2, 3 ).resultado ); //usando metodo elevar ( da role Potencia )
  console.log( calc.raiz_quadrada(   calc.elevar( 2, 3 ).resultado ).resultado  ); //usando metodo raiz_quadrada ( da role RaizQuadrada )
  console.log( calc.adicionar( 1,3 ).resultado ); //usando metodo adicionar que está na minha CalculadoraBase

Uma Role tambem pode incluir outras Roles... por exemplo, vou definir uma role Dormir:

  Role( "Dormir", {
    methods: {
      dormir: function () { 
        console.log( "  dormir...." );
      }
    }
  } )

e vou criar outras 3 roles, que tambem vão usar a role dormir:

  Role( "DescancoProgramador" , {
    does: Dormir,
    after: {
      programar : function() { 
        console.log("depois de programar: ");
        this.dormir() 
      },
    }
  } )

  Role( "DescancoPiloto" , {
    does: Dormir,
    after: {
      pilotar : function() { 
        console.log("depois de pilotar: ");
        this.dormir() 
      },
    }
  } )

  Role( "DescancoMecanico" , {
    does: Dormir,
    after: {
      consertar_carro : function() { 
        console.log("depois de consertar o carro:");
        this.dormir() 
      },
    }
  } )

Então é isso, eu posso montar uma role de roles e classes com roles. Parece LEGO.

=head3 Requires

As roles podem utilizar métodos que estão em outras classes. Ou, que estão em outras roles. E para não ficar validando dentro de cada método, é possível simplesmente dizer que uma role 'requires' um determinado método para poder ser usada. Isso evita eu precisar fazer " if ( ! this.algum_metodo ) { executar } else { alert('metodo algum_metodo não está disponível') } ".  ** obs o setNomeAtributo tambem é um método.. ou seja, tambem é possivel requerer atributos.

exemplo, primeiro vou definir uma classe pessoa:

  Class( "PessoaSimples" , { 
    has: {
      nome: { is: "rw" }
    }
  })

agora vou definir uma Role "Paraquedas", que implementa as funcionalidades de um paraquedas. Observe que essa role requires o método 'pular_do_aviao'. Ou seja, eu só posso usar essa role em classes/roles que implementam um método chamado 'pular_do_aviao'

  Role( "Paraquedas" , {
    requires: [               //para usar essa role, tem que estar definido:
      'pular_do_aviao',       //metodo pular do aviao. 
      'setNivel_paraquedista' //atributo nivel_paraquedista
    ],
    has : {
      cor_paraquedas: { is : "rw", init: ( function(){return"paraquedas azul"})() }
    },
    methods: {
      abrir_paraquedas: function () { 
        console.log( "abriu paraquedas" );
      },
      pular: function () { 
        this.pular_do_aviao(); /// eu vou executar este metodo que esta em outra classe!! por isso eu "requires" que ele exista...
                               //senão eu teria que fazer validação aqui mesmo e ia ficar horrivel, ex (de coisa horrivel):
                               //if ( typeof this.pular_do_aviao != "undefined" ) { this.pular_do_aviao }  //eca!!   vs  requires : [ "pular_do_aviao" ]
                               //isso sem dizer que seria necessario validar em todos os pontos que fariam uso do método.... ah vá... requires é bem melhor
      }, 
    }
  } )

E agora vou implementar minha classe Paraquedista, que vai herdar de pessoa, e vai usar a Role "Paraquedas" 

  Class( "Paraquedista" , {
    isa : PessoaSimples,
    does: [Paraquedas],
    has : {
      nivel_paraquedista: { is : "rw" }
    },
    methods : { 
      pular_do_aviao : function () {
        console.log( "pulando " );
      }
    }
  } )

=head3 Types

Coerção de tipos é a mão na roda em javascript pois normalmente os atributos recebem dados de usuários ou aplicações que estão em formato string, ou em formatos errados/indesejados. E a coerção oferece uma maneira muito conveniente ( e centralizada ) de transformar o dado de entrada no formato que eu quero. 

O uso é simples, como eu disse fica junto do atributo, por exemplo: 

  Class( "Pessoa", {
    has : {
      nome : {
              is : "rw",
             isa : Joose.Type.ExemploTipoString, //<-- atributo nome vai implementar o tipo ExemploTipoString
          coerce : true,
            lazy : true,
      },
      sobrenome : {
              is : "rw",
             isa : Joose.Type.ExemploTipoString,
          coerce : true,
      },
      idade : {
               is : "rw",
              isa : Joose.Type.ExemploTipoNumerico, //<-- vai virar numerico
           coerce : true,
      },
      peso : {
               is : "rw",
              isa : Joose.Type.ExemploTipoPeso,    //vai receber um numero e vou retornar numero+" kg".
           coerce : true,
      },
    },
    methods : {
      andar : function () {
        //...
      },
    }
  } )

A idéia de tipos, é definir os tipos e amarrar eles aos atributos. Assim não será mais necessário ficar fazendo por exemplo, parseInt( variavel ) toda hora. Se eu não usasse types, eu teria que adicionar uma validação dentro do meu setNomeAtributo.. eu teria que adicionar um if ( is_numerico(valor) ) { this.setNomeAtributo( valor ) } else { this.setNomeAtributo( parseInt( valor ) ) } e etc etc... horrível pra não dizer algo pior.

Vou definir um tipo "ExemploNumerico". 

  Type( "ExemploTipoNumerico" , {
    uses  : Joose.Type.Any,
    where : function ( val ) {
      if ( val == null ) return true; //se for nulo permite setar valor (eu simplesmente permiti uma excessão ao valor null)
      return false;                   //se não for nulo pode ser qualquer coisa, string, objeto, etc. vai retornar false e
                                      //vai rodar as regras de coerce abaixo. As regras de coerce são opcionais e servem
                                      //para transformar um valor recebido no valor que desejado.
    },
    coerce : [ //coerce transforma o valor no que eu quero
      {
        from  : Joose.Type.Any,
        via   : function ( val ) {
          var pattern_digits = /^(\d+)$/ig;
          if ( ! pattern_digits.test( val ) ) {
            return false;
          }
          return parseFloat( val );
        }
      }
    ]
  } )

e um tipo string

  Type( "ExemploTipoString", {
     uses : Joose.Type.Any,
    where : function ( val ) {
      if ( typeof val == "string" || val == null ) return true; //ta liberado pra setar nulo
      return false;
    },
    coerce: [
        //primeira regra
        {
          from : Joose.Type.Any,
           via : function ( val ) {
             console.log( Joose.Type.Any );
            if ( typeof val != "string" ) return ""+val; //transforma valor recebido em string
            return val;
          }
        }
    ]
  } )

e agora eu posso instanciar minha classe pessoa com os valores que ela se vira pra arrumar eles pra mim... se eu passar um numero num artributo ExemploTipoString, o numero será transformado em string... e se eu passar algo que não sejam numeros para o tipo "ExemploTipoNumerico" vai retornar false; Caso contrário meu coerce vai executar um parseFloat! veja o exemplo:

  var pessoa = new Pessoa();
  pessoa.setNome( "João" );
  pessoa.setSobrenome( "da Silva" );
  console.log( pessoa.nome );


  var pessoa2 = new Pessoa( {
           nome : 11,     //passei um numero aqui, automaticamente vai rolar um coerce e nome vai ser transformado em string.
                          //mas eu poderia mudar a regra e retornar false se tivesse numeros no nome. fica a seu critério
      sobrenome : "Silva",
          idade : 50,
           peso : 91.2
  } );

  console.log( pessoa2.nome );      //false
  console.log( pessoa2.sobrenome ); //Silva
  console.log( pessoa2.idade );     //50


Ou vc pode querer definir um atributo como instância de outra classe, mas de acordo com o valor inserido no atributo. Por exemplo, se eu tiver uma classe "MeioDeTransporte" com atributo "veiculo" , e setar esse atributo como a string "barco", eu quero que esse atributo vire uma classe Barco e deixe de ser uma simples string. Por exemplo:

Primeiro eu defino as classes e os typos:

  Class( "Barco", {
    has : {
      nome: { is: "ro", init: (function(){return"Barco"})() }
    },
    methods : {
      navegar: function () { 
        console.log( "sou um " + this.nome + " e vou nagevar." );
      }
    }
  } )

  Class( "Carro", {
    has : {
      nome: { is: "ro", init: (function(){return"Carro"})() }
    },
    methods : {
      pegar_estrada: function() { 
        console.log( "sou um " + this.nome + " e vou pegar a estrada." );
      }
    }
  } )

  Class( "Aviao", {
    has : {
      nome: { is: "ro", init: (function(){return"Aviao"})() }
    },
    methods : {
      voar: function () { 
        console.log( "Sou um " + this.nome + " e vou voar." );
      }
    }
  } )

  Class( "Trem", {
    has : {
      nome: { is: "ro", init: (function(){return"Trem"})() }
    },
    methods : {
      andar_no_trilho: function () { 
        console.log( "Sou um " + this.nome + " e vou andar nos trilhos." );
      }
    }
  } )

e os tipos: 

  Type( "Transporte" , {
    uses : Joose.Type.Any,
    where : function ( val ) { 
      return false;
    },
    coerce: [
      {
        from : Joose.Type.Any,
          via : function ( val ) { 
            switch ( val.toLowerCase() ) {

              case "barco":
                return new Barco(); 
                break;

              case "carro": 
                return new Carro(); 
                break;

              case "aviao":
                return new Aviao();
                break;

              case "trem":
                return new Trem();
                break;

              default: 
                return false;
                break
           }
        }
      }
    ]
  } )

e depois eu defino uma classe que vai usar o tipo: Joose.Type.Transporte,

  Class( "MeioDeTransporte" , {
    has : { 
      veiculo: { 
               is : "rw" ,
              isa : Joose.Type.Transporte,
           coerce : true,
      }
    },
    methods : { 
      veiculo_utilizado: function () {
        console.log( "Estou usando o veiculo: " + this.veiculo.nome );
      }
    }
  } )

e ai eu uso essa bagaça assim :

  var meio_de_transporte_1 = new MeioDeTransporte( { veiculo: "carro" } );
  //como o atributo veiculo é um Joose.Type dentro da classe MeioDeTransporte, o atri-
  //buto automagicamente será transformado no tipo especificado de acordo com o valor 
  //que vc passar pra ele. oh que beleza!
  console.log( meio_de_transporte_1.veiculo );
  console.log( meio_de_transporte_1.veiculo.nome );
               meio_de_transporte_1.veiculo.pegar_estrada();

  var meio_de_transporte_2 = new MeioDeTransporte( { veiculo : "aviao" } );
  console.log( meio_de_transporte_2.veiculo.nome );
               meio_de_transporte_2.veiculo.voar();

  var meio_de_transporte_3 = new MeioDeTransporte( { veiculo : "trem" } );
  console.log( meio_de_transporte_3.veiculo.nome );
               meio_de_transporte_3.veiculo.andar_no_trilho();

  var meio_de_transporte_4 = new MeioDeTransporte( { veiculo : "barco" } );
  console.log( meio_de_transporte_4.veiculo.nome );
               meio_de_transporte_4.veiculo.navegar();


  var meio_de_transporte_5 = new MeioDeTransporte( { veiculo : "NAO DEFINID...BLAA." } );
  console.log( meio_de_transporte_5.veiculo ); // vai retornar false, pois tem essa regra no Type: Transporte

=head3 Namespaces

namespaces ajudam a agrupar partes da aplicação, vou dar um exemplo: 

Vou definir um namespace: "Automovel.Motor"

  Module( "Automovel.Motor", function() { 
    Role( "Corrida" , { 
      has: { 
        turbo: { is: "rw", init: true },
        lugares: { is: "rw", init: 1 },
        potencia: { is: "rw" }
      },
      methods: { 
        acelerar_fundo: function () {
          console.log( "carro de corrida, acelerando fundo ..." );
        } 
      }
    } ),
    Role( "Passeio" , { 
      has: { 
        turbo: { is: "rw", init: false },
        lugares: { is: "rw", init: 4 }
      },
      methods : { 
        andar_na_boa: function () { 
          console.log( "carro de passeio, andar na boa ..." );
        }
      }
    } )
  } ),

E agora vou definir um namespace: "Automovel.Modelo"

  Module( "Automovel.Modelo", function() { 
      Class( "Ferrari" , {
        has: { 
          modelo: { is: "rw" , init: "ferrari testarrosa" }
        },
        does: [ Automovel.Motor.Corrida ]
      } ),
      Class( "Porshe", {
        has: { 
          modelo: { is: "rw" , init: "porshe 911" }
        },
        does: [ Automovel.Motor.Corrida ]
      } ),
      Class( "Fusca", {
        has: { 
          modelo: { is: "rw" , init: "fusca antigo" }
        },
        does: [ Automovel.Motor.Passeio ]
      } ),
      Class( "Monza" ,  { 
        has: { 
          modelo: { is: "rw" , init: "monza 2.0" }
        },
        does: [ Automovel.Motor.Passeio ]
      } )
  } )

E o uso dessa bagaça fica: 

  var ferrari = new Automovel.Modelo.Ferrari( { potencia: "400 cavalos", lugares: 2 } );
  console.log( ferrari.modelo );
  console.log( "is turbo? "+ ferrari.turbo );
  ferrari.acelerar_fundo();

  var porshe = new Automovel.Modelo.Porshe( { potencia: "300 cavalos", lugares: 2 } );
  console.log( porshe.modelo );
  console.log( "is turbo? "+ porshe.turbo );
  porshe.acelerar_fundo();

  var fusqueta = new Automovel.Modelo.Fusca( );
  console.log( fusqueta.modelo );
  console.log( fusqueta.lugares );
  console.log( "is turbo? "+ fusqueta.turbo );

  var monzinha = new Automovel.Modelo.Monza();
  console.log( monzinha.modelo );
  console.log( monzinha.lugares );
  console.log( "is turbo? "+ monzinha.turbo );

=head3 Singletons

O singleton é uma classe que é instanciada automaticamente na sua app e, você não pode criar mais instâncias dela.. apenas uma instancia vai existir na app e poderá ser acessada de qualquer ponto da aplicação. Por isso o nome Singleton. Veja o exemplo:

Primeiro vou criar minha classe singleton chamada: SingletonAloAlo. Ela tem 1 método que vai falar "alô alô". E tem um contador de quantas vezes já falou alô alô.

  Class("SingletonAloAlo", {
      does: [Joose.Singleton],
      has: {
          count_chamadas_alo_alo: {
              is: "rw",
              init: function() { return 0 }
          }
      },
      methods: {
          alo_alo_from_singleton: function() {
              this.setCount_chamadas_alo_alo( this.getCount_chamadas_alo_alo() + 1 );
              console.log( "alô alô" );
          }
      }
  })

feito isso, quando minha aplicação inicializar, eu consigo acessar a instância desse singleton, da seguinte maneira:

  var singleton = SingletonAloAlo.getInstance();  //pega a referencia do singleton e joga na variavel singleton
  singleton.alo_alo_from_singleton();             //falou alô alô e contabilizou +1 
  singleton.alo_alo_from_singleton();             //falou alô alô e contabilizou +1 
  singleton.alo_alo_from_singleton();             //falou alô alô e contabilizou +1 
  console.log( singleton.count_chamadas_alo_alo );//mostra 3 

E agora vamos supor que estou em outro ponto da aplicação e quero recuperar meu singleton, posso fazer:


  var singleton_2 = SingletonAloAlo.getInstance();    //recupera a referência do meu singleton
  console.log( singleton_2.count_chamadas_alo_alo );  //mostra 3 pois existiram 3 chamadas anteriores do metodo que fala alôalô

=head3 Prototypes

=head2 Exemplo prático

Para ver mais exemplos, abra o arquivo ./calculadora.htm  e veja o arquivo: ./lib/calculadora.js

=head3 Exemplo 1 - Carros e motores

  Class( "EstiloCorrida", {
    methods: {
      acelerar: function() {
        console.log( "Acelerando muito rapido pois este motor é de corrida" );
      },
      brecar: function() {
        console.log( "Brecando com freios ABS... carro de corrida sempre tem" );
      },
    } 
  } )
  Class( "Estilo4x4", {
    methods: {
      acelerar: function() {
        console.log( "Acelerando o máximo com este motor de 4x4." )
      },
      brecar: function() {
        console.log( "Brecando sem abs neste modelo 4x4" );
      },
    } 
  } )

  Class( "Lamborghini", {
    has: { 
      engine: {
        is: "rw"
      }
    },
    methods: {
      acelerar: function () {   
        this.engine.acelerar();
      },
      brecar: function() {  
        this.engine.brecar();
      }
    },
    after: {
      setEngine: function () {
        console.log( "Configurada classe com motor: " + this.engine.meta._name );
      }
    }
  } )

  Class( "Jeep", {
    has: { 
      engine: {
        is: "rw"
      }
    },
    methods: {
      acelerar: function () {   
        this.engine.acelerar();
      },
      brecar: function() {  
        this.engine.brecar();
      }
    },
    after: {
      setEngine: function () {
        console.log( "Configurada classe com motor: " + this.engine.meta._name );
      }
    }
  } )

e o uso:

  var jeepao = new Jeep( { engine: new Estilo4x4() } );
  var diablo = new Lamborghini( { engine: new EstiloCorrida() } );

  jeepao.acelerar();
  jeepao.brecar();

  diablo.acelerar();
  diablo.brecar();


=head3 Exemplo 2 - Calculadora

Como exemplo incial, vou começar com uma calculadora. A idéia é criar uma classe inicial com as funções básicas de somar, subtrair, dividir e multiplicar e um atributo resultado.

  Class( "Calculadora", {
    has : {
      resultado: { is : "rw", init: (function() { return 0 }) }
    },
    methods : {
      adicionar: function ( val1,val2 ) {
        this.setResultado( val1 + val2 );
        return this;
      },
      subtrair: function( val1,val2 ) {
        this.setResultado( val1 - val2 );
        return this;
      },
      multiplicar: function ( val1, val2 ) {
        this.setResultado( val1 * val2 );
        return this;
      },
      dividir: function( val1, val2 ) {
        this.setResultado( val1 / val2 );
        return this;
      },
      zerar: function( ) {
        this.setResultado( 0 );
        return this;
      }
    }
  } )

e a seguir, um exemplo de uso:

  var calc = new Calculadora();
  calc.adicionar( 1, 2 );         //soma 1 com 2 e armazena o resultado no atributo "resultado"
  console.log( calc.resultado );  //mostra 3

E para extender a calculadora posso simplesmente criar novas Roles e criar uma classe que extende a calculadora, ex:

  Class( "CalculadoraBase", {
    has : {
      resultado: { is : "rw", init: (function() { return 0 }) }
    },
    methods : {
      adicionar: function ( val1,val2 ) {
        this.setResultado( val1 + val2 );
        return this;
      },
      subtrair: function( val1,val2 ) {
        this.setResultado( val1 - val2 );
        return this;
      },
      multiplicar: function ( val1, val2 ) {
        this.setResultado( val1 * val2 );
        return this;
      },
      dividir: function( val1, val2 ) {
        this.setResultado( val1 / val2 );
        return this;
      },
      zerar: function( ) {
        this.setResultado( 0 );
        return this;
      }
    }
  } )

  Role( "RaizQuadrada", {
    methods: {
      raiz_quadrada: function( val1 ) {
        this.setResultado(  Math.sqrt( val1 )  );
        return this;
      }
    }
  } )

  Role( "Potencia" , {
    methods: {
      elevar: function ( val1, val2 ) {
        this.setResultado( Math.pow( val1, val2 ) );
        return this;
      }
    }
  } )

e depois eu crio uma classe Calculadora que extende minha calculadorabase e adiciona as roles de RaizQuadrada e Potencia

  Class( "Calculadora", {
    isa: CalculadoraBase,
    does: [
      RaizQuadrada,   //agora esta classe implementa as funcionalidades de raiz quadrada
      Potencia,       //agora tambem implementa funcionaldiade de potencia
    ]
  } )

  var calc = new Calculadora();
  console.log( calc.elevar( 2, 3 ).resultado );
  console.log( calc.raiz_quadrada(   calc.elevar( 2, 3 ).resultado ).resultado  );

=head3 Extendendo a calculadora - Raíz quadrada

Para extender a calculadora, vou criar uma Role que contém um método de raíz quadrada

=head4 Referências

http://code.google.com/p/joose-js/

Alguns trechos são traduzidos/copiados da documentação oficial do joose.

=head4 Autor

Hernan Lopes

=head4 Colaboradores

Se você ajudar a melhorar este documento, adicione seu nome abaixo.

=cut
