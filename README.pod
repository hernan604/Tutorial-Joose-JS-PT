=encoding utf8

=head1 NAME

Tutorial Joose JS - em portugês

=head2 SYNOPSE

Joose é um sistema de meta objetos para javascript que suporta:

  classes
  herança
  traits
  modificadores de método

E permite que você crie classes como se fosse LEGO, literalmente.

=head2 DESCRIÇÃO

Joose é um sistema de meta objetos para javascript.

O joose facilita o trabalho com orientação a objeto no javascript. Fica mais fácil, declarativo e aumenta a produtividade. O sistema de meta objetos do joose é multiparadigma, ou seja, ele suporta desenvolvimento voltado a classes, prototypos e tambem suporta herança de classes e extensão com roles.

Importante, o joose não serve apenas para frontend. Tambem é muito usado no backend junto com nodejs. É importante entender que o joose não está atrelado a markup nem a views. No entando ele pode ser usado no frontend (browser) e usar jquery ou javascript puro para modificar o dom e etc. E o Angular, Dojo, ExtJS, etc por exemplo podem ser usadas em conjutno com o joose.

O joose ajuda a trabalhar com classes, namespaces, heranças, roles, reduzir o número de linhas, reutilizar código e aumentar a produtividade.

=head2 O que NÃO é Joose JS

Joose não é um manipulador de DOM. Ex. ele não faz o que o jquery faz.

Ele não trabalha no nível de markup. Mas pode ser usado em conjunto com jquery.

=head3 Seters, getters

Como é feito normalmente em js: 

  pessoa = {
    //nome
    nome      : null,
    setNome  : function ( val ) { 
      this.nome = val;
    },
    getNome  : function () { 
      return this.nome;
    },

    //sobrenome
    sobrenome      : null,
    setSobrenome  : function ( val ) { 
      this.sobrenome = val;
    },
    getSobrenome  : function () { 
      return this.sobrenome;
    },

    //idade
    idade    : null,
    setIdade  : function ( val ) {
      this.idade = val;
    },
    getIdade  : function () { 
      return this.idade;
    },

  };
  pessoa.setNome("João");
  pessoa.setSobrenome("Silva");
  pessoa.setIdade(50);

  pessoa.getNome();

Não ha necessidade de ficar declarando setters e getters pois todo atributo tem um setter e um geter criado implicitamente. Você pode mudar o nome dos getters e setters. Especialmente se quiser usar um after ou before de setters ou getters.

ex, primeiro vou criar e definir minha classe Pessoa: 

  Class( "Pessoa", {
      has: {
          nome        : { is: 'rw' },
          sobrenome   : { is: 'rw' },
          idade       : { is: 'rw' },
          amigos      : { is: 'rw', init: (function() { })( return [] ) }, // Array
      }
  } )

Agora, vou instanciar a classe e setar alguns atributos manualmente

  var pessoa = new Pessoa();
  pessoa.setNome( "João" );
  pessoa.setSobrenome( "João" );
  pessoa.setIdade( "João" );
  pessoa.setAmigos( [ 'Maria','José' ] );

ou melhor ainda, vou instanciar a classe passando um objeto e a classe é automagicamente populada para vc, ex:

  var pessoa_item = {
          nome : "João",
     sobrenome : "Silva",
         idade : 50,
        amigos : [ "José", "Maria" ]
  }

  var p = new Pessoa( pessoa_item );
  console.log( p.nome );      // João
  console.log( p.sobrenome ); // Silva
  console.log( p.idade );     // 50
  console.log( p.amigos );    // [ "José", "Maria" ]

menos código, menos bugs. Mais clean.

=head3 Atributos

Todas as Classes e Roles podem ter atributos. Ao registrar um atributo para sua classe, um attribute accessor é criado para você.

Os atributos ficam dentro do bloco has. 
  
  has: {
      nome: { 
          is: "rw"    //rw = readwrite. Ou seja, é permitido escrever nesse atributo
      },
      sexo: {
                is : "ro"    //ro = readonly. Ou seja, não é permitido escrever nesse atributo
          required : true,   //indica que o atributo é requerido
      }
  }

Foi escolhido 'has' pois atributos são considerados membros de um objeto, ou seja, "um objeto has um atributo", ou "um objeto tem um atributo", ou "uma pessoa tem nome"

Isso quer dizer que você só indica o nome do atributo e os getters e setters são criados behind-the-scenes.

o padrão para os accessors é set junto com a primeira letra do atributo em maiúscula, ex:

  Class( "Pessoa" , {
    has: {
      nome: { is: "rw" }
    }
  } )

  var pessoa = new Pessoa();

o setter fica:

  pessoa.setNome( "valor" )

e o getter fica:

  pessoa.getNome()

óbviamente que vc tambem pode fazer:

  pessoa.nome

  ou 

  pessoa.nome = "Mônica"

Resumindo, para acessar os atributos de fora da classe:

  pessoa.nome

e para acessar de dentro da classe:

  this.setNome( '...' );
  this.getNome()
  this.nome

mas ao vc acessar/setar diretamente o atributo, vc perde a facilidade dos modificadors de método para getPessoa e setPessoa.

=head3 Métodos

Os métodos podem ser definidos tanto em Classes quanto em Roles. e ficam dentro do bloco methods:{ ... }, ex:

  Class( "Programador", {
    isa : Pessoa,         //herda da classe Pessoa
    has : {
      is_hacker : { is: "rw", init: ( function() { true } )() }
      linguagem : { is: "rw"  },
    },
    methods : {               //bloco de métodos relacionado à classe Programador
      programar: function () {
        console.log( "programando.... " );
      },
      hackear: function() {
        if ( ! this.is_hacker ) return;
        console.log( "hummmmm hacker :p" );
      }
    }
  } )

A classe Programador acima, herda de pessoa, então ela tem todas as funcionalidades da classe pessoa.

Alem disso, alguns métodos são definidos especificamente nesta classe, são eles:

  programar
  hackear

Então eu poderia fazer isto por exemplo:

  var dados = {
         nome : "Linus Torvalds",
    is_hacker : true,
    linguagem : [ "c", "cpp" ]
  }

  var programador = new Programador( dados );

  programador.programar() // programando...
  programador.hackear()   // hummmmm hacker :p

mas e se eu passar is_hacker = false

  programador.setIs_hacker( false );
  programador.hackear();  // vai fazer nada pois não é hacker

para setar atributos dentro dos métodos é só fazer:

  this.setNome("...")
  this.getnome()
  this.nome

=head3 Modificadores de métodos

Os modificadores de métodos tem muitos usos. Eles são bastante usados em Roles pois as roles extendem as classes e assim é possível pegar carona nos métodos sem necessariamente alterar os métodos da classe principal.

Os modificadores de método recebem os mesmos atritos enviados para o método original.

Existem 4 modificadores de método:

  before 
  after
  override
  around

Before e After rodam antes e depois dos métodos respectivamente e não permitem alterar o valor enviado e nem o valor retornado pelo método original. Um exemplo de uso seria registrar um 'log' da ação executada. ex:

  Class( "Pessoa", {
    has : {
      nome : { is: "rw" }
    },
    before: { 
      setNome: function( nome ) {
        console.log( "LOG: Antes de setar atributo nome, com valor: " + nome );
      }
    },
    after: {
      setNome: function( nome ) { 
        console.log( "LOG: Após setar atributo nome, com valor: " + nome );
      }
    }
  } )

Então se eu instanciar essa classe e setar um valor para o atributo nome, ela vai fazer o seguinte:

  var pessoa = new Pessoa();
  pessoa.setNome( "Joe" );

  "Antes de setar atributo nome"<-- aparece antes da classe chamar o método setNome
  "Após setar atributo nome"    <-- aparece após a classe setar um valor para o atributo nome

Outros modificadores de métodos mais poderosos são o Override e Around. Estes podem modificar os argumentos passados originalmente para um método e você consegue até decidir se quer ou não chamar o método original. Também é possível modificar o valor retornado pelo método original, ex:

  Class( "Pessoa", {

    // Métodos 

    methods: {
      dizer_frase: function ( frase ) {
        return "dizendo: " + frase ;
      },
      perguntar_frase: function( pergunta ) {
        return "perguntando: " + pergunta;
      },
    },

    // Meus overrides

    override: {
      dizer_frase: function( frase ) {
        return this.SUPER( false ) + " - OVERRIDE";
      }
    },

    //Meus arounds

    around: {
      perguntar_frase: function ( original, pergunta ) {
        return ( pergunta && pergunta.length > 10 ) 
          ? original( pergunta )        //chama o método original
          : "pergunta muito curta";     //não chama método orignal e retorna este valor
      }
    },
  } )

  var pessoa = new Pessoa();
  console.log( pessoa.dizer_frase( "Tambem sei falar!" ) );
  console.log( pessoa.perguntar_frase( "Nome?" ) );
  console.log( pessoa.perguntar_frase( "Qual seu nome ?" ) );


=head4 before

O before permite que seja executado algo antes da execução do método relacionado ao before.

  Class( "Pessoa", {
    has: {
      nome: { is: "rw" }
    },
    before: {
      setNome: function () { 
        console.log( "Antes de executar this.setNome('...') " );
      }
    }
  } )

=head4 after

O after permite executar algo após a execução do método.

=head3 Classes

=head3 Roles

=head3 Requires

=head3 Traits

=head3 Types

Type coercions have been proven to be extremely useful in JavaScript code because many tasks in JavaScript deal with user provided data that is in string form. Coercions provide a very convenient way to transform this string data into meaningful things. After the definition of the types your application code can basically "ignore" things like data validation and conversion. This makes the code more expressive and should reduce errors because it is harder to forget to validate data.

REFENCIA: http://www.nonblocking.io/2009/01/type-contraints-and-type-coercions-in.html 

=head3 Namespaces

=head3 Singletons

=head3 Prototypes

=head2 Exemplo prático

=head3 Calculadora

Como exemplo incial, vou começar com uma calculadora. A idéia é criar uma classe inicial com as funções básicas de somar, subtrair, dividir e multiplicar e um atributo resultado.

  Class( "Calculadora", {
    has : {
      resultado: { is : "rw", init: (function() { return 0 }) }
    },
    methods : {
      adicionar: function ( val1,val2 ) {
        this.setResultado( val1 + val2 );
        return this;
      },
      subtrair: function( val1,val2 ) {
        this.setResultado( val1 - val2 );
        return this;
      },
      multiplicar: function ( val1, val2 ) {
        this.setResultado( val1 * val2 );
        return this;
      },
      dividir: function( val1, val2 ) {
        this.setResultado( val1 / val2 );
        return this;
      },
      zerar: function( ) {
        this.setResultado( 0 );
        return this;
      }
    }
  } )

e a seguir, um exemplo de uso:

  var calc = new Calculadora();
  calc.adicionar( 1, 2 );         //soma 1 com 2 e armazena o resultado no atributo "resultado"
  console.log( calc.resultado );  //mostra 3

Nos próximos capítulos, a calculadora será extendida para ter mais funcionalidades mas sem mexer na calculadora básica.

=head3 Extendendo a calculadora - Raíz quadrada

Para extender a calculadora, vou criar uma Role que contém um método de raíz quadrada

=head4 Referências

http://code.google.com/p/joose-js/

Alguns trechos são traduzidos/copiados da documentação oficial do joose.

=head4 Autor

=head4 Colaboradores

Se você ajudar a melhorar este documento, adicione seu nome abaixo.

=cut
